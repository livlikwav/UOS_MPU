
## 바로 뻔뻔강사 AVR 강의 보기

### 1강 왜 avr 인가
avr 사용하는 이유
* 개발에 필요한 sw , hw가 거의 대부분 공개, 무료
* 메모리 사용이 너무 쉽다
* 관련 사업분야 zigbee bluetooth usn can rfid robot등이 avr채택함

### avr 위키
아트멜 AVR(Atmel AVR)은 1996년 아트멜 사에서 개발된 하버드 구조로 수정한 8비트 RISC 단일칩 마이크로컨트롤러이다. 출시 당시 AVR은 프로그램을 저장하기 위해 이용한 메모리 방식을 다른 마이크로컨트롤러 처럼 ROM, EPROM 또는 EEPROM 을 사용하지 않고, 단일칩 플래시메모리를 사용한 최초의 마이크로컨트롤러 중 하나이다.

AVR의 구성
AVR은 중앙처리장치와 소용량 플래시메모리가 하나의 IC에 집적되어 있다.
AVR 하버드구조(Harvard architecture)의 변형 형태로 프로그램과 데이터 메모리가 분리된 형태이다. 특수 명령어로 프로그램 데이터를 데이터 영역으로 읽을 수 있다.

AVR의 종류
아트멜 AVR은 AVR이 있으며 그 중, ATmega128이 교육용으로 가장 흔하게 쓰인다.

### 뻔뻔강사 2강 어떤 컴파일러 사용?
Avr 컴파일러 종류
avr-gcc(winavr)
> linux에서 사용되던 gcc를 avr용으로 변환
IAR EWAVR
CodeVision
ICC AVR

결론
 결국, 어떤 컴파일러를 선택해야 하는가?
1) AVR 초보 입문자
AvrEdit를 강력 추천합니다.

2) AVR 경험자 : 혼자서 어떤 식으로든 해결할 수 있는 레벨
WINAVR + AVR Studio를 추천합니다.

3) AVR 경험자 : 외부의 도움과 지원이 필요한 레벨
상용 컴파일러를 추천합니다.

4) AVR외 다양한 프로세서들 대상으로 개발하고 있는 혹은 개발해야 할 개발자
이 역시 상용 컴파일러를 추천합니다.

5) 향후 ARM 기반 Embedded Linux 등을 공부 or 개발하고 싶은 개발자
AvrEdit 혹은 WINAVR + AVR Studio를 추천합니다. 

※ 컴파일러를 변경하면 소스 코드 어떤 부분들을 수정해 주어야 하나요?

-헤더(Header) : 각 컴파일러 마다 AVR 프로세서 내 SFR과 인터럽트 벡터들을 선언하는 헤더 파일의 이름들이 모두 다르므로, 컴파일러를 변경하게 되면 반드시 AVR 프로세서 관련 헤더 파일들을 변경해 주어야 한다.

-인터럽트 서비스 루틴(ISR) 선언 : 앞서 설명한 대로 AVR-GCC에서는 sei()함수를 사용하나, IAR EWAVR에서는 __enable_interrupt()를 사용하는 등, ISR을 선언하는 방법이 컴파일러마다 모두 다르다. 그러나, ISR 내 소스 코드는 통상적인 C언어 문법을 따르고 있으므로, 선언하는 부분만 변경하면 된다.

임베디드 소프트웨어든, 일반 소프트웨어든 소프트웨어를 개발하려면 무조건 컴파일러, (시스템)라이브러리, 바이너리 유틸리티 이렇게 3가지가 필요하며 GCC는 그 중 컴파일러에 속한 소프트웨어 입니다.

실제로 Sun Solaris 나 HP UX, IBM AIX 등과 같은 전통적인 UNIX에서는 사용 컴파일러인 CC를 사용하는데, 이 컴파일러와 컴파일러 메뉴얼의 가격이 천만원 상당에 이르기 때문에, 보통 UNIX에서도 GCC를 가져다가 개발하는 사례도 상당히 많을 정도로 그 안정성과 성능이 이미 입증되어 있는 컴파일러가 바로 GCC 입니다.

1. volatile 선언. GCC말고 다른 상용 컴파일러는 다 하나의 task로 구성되어 있는 firmware 이기 때문에 스케줄링이 되지 않는다. 한번 메모리에 로딩되면 전원이 꺼질 때까지 그 주소 값을 유지할 수 있다.

### GCC 위키
GNU Compiler Collection
GNU 프로젝트의 오픈 소스 컴파일러 컬렉션. 유닉스 계열 플랫폼의 De-Facto Standard 컴파일러다. 리처드 스톨먼이 1987년에 만들었다.

처음에는 C 컴파일러였으며 'GNU C Compiler'의 약어였다. 하지만 기능이 추가되면서 C++ 같은 다른 언어도 지원하게 되었고[1], 'GNU Compiler Collection'으로 이름을 변경하였다. 물론 약어는 여전히 GCC이다. 공식적으로 지원하는 언어는 C, C++, Objective-C, Fortran, Ada, Go이다. Java는 GCC 7.1 버전부터 지원이 중단되었다.

원래는 C로 구현되었으나 2013년에 구현 언어를 C++로 모두 변경하였다. # 만들어진지 수십년 된 컴파일러라 최적화는 매우 잘 되어 있지만, 기존 코드의 구조가 시대적 한계로 인해 오늘날 관점에서는 상당히 더러워서 신규 인력이 거의 유입되지 않았기 때문이다

## avr 뻔뻔강사 강의 3
왜 avr atmega 128일까요
용어 
* fetch
* decode
* execute
* general purpose register
* clock
* cycle
* MIPS (milion instruction per second)

---소프트웨어 개발자 입장에서 바라 본 하드웨어(디바이스)는 크게 2가지로 나눠서 생각할 수 있습니다.

먼저 CPU나 인터넷(TCP/IP) 접속을 가능하게 하기 위한 Ethernet 칩처럼 스스로 어떻게 동작해야 할지 소프트웨어를 통해 결정할 수 있는 "능동 소자"와 LED나 Button 처럼 자기 스스로 어떻게 동작해야 할지 결정할 수 없기 때문에 능동 소자와 연결하여 능동 소자에 의해 간접적으로 (소프트웨어를 통해) 제어되는 "수동 소자"로 나눠지게 됩니다. 결국 우리가 작성하는 임베디드 소프트웨어는 "능동 소자"를 제어하는 소프트웨어라 할 수 있습니다.

능동 소자를 소프트웨어로 제어하는 방법은 결국 한 가지. 레지스터(Register) 비트 값을 설정하는 것 밖에 없습니다.

1. 왜 AVR 인가요?
흔히 프로세서 성능 - 클럭Clock을 가지고 비교한다
Fetch = Pc Program Count가 가리키고 있는 메모리RAM 주소로 쫒아가 해당 코드를 CPU Core로 가져오는 작업
Fetch에 의해 가져온 코드는 CPU Core 내부에 있는 Latch라는 부품에 잠시 저장
Latch의 코드가 어떤 명령어와 인자 값으로 구성되어 있는 지 해석 = Decode
Decode 된 후에는 인자값들을 Latch 밑에 있는 범용 레지스터 General Purpose Register에 저장되었다가,
마지막으로 실제 SW 연산 처리를 ㄷ마당하고 있는 ALU에 의해 실행된다
즉 Execute 되는 부품이 바로 CPU 이다
이 과정을 전원이 들어오는 순간 부터 꺼지는 순간까지 무한 반복하는게 CPU 이다.

Clock
어떤 작업이 순차적으로 진행이 되려면, 언제 다음 작업으로 넘어가야 할지 시간을 측정해야 하며, 이때 사용되는 부품

대부분의 CPU는 하나의 명령어가 실행되기까지 보통 3~4 클럭 정도가 소요된다 = 이를 '사이클'

위에서만 봐도 하나의 CPU 명령어 instruction이 실행되기 까지 3단계의 작업, 즉, 3클럭 정도가 소요될거라 예상할 수 있다.

Single Clock Cycle Execution은 하나의 명령어가 실행될 대 대부분 1클럭 밖에 걸리지 않을 정도로 매우 빠른 CPU라는 뜻이다. 

Up to 16MIPS Throughput at 16MHz 는 1초당 몇 백만개의 CPU 명령어가 수행되는 지 실제 CPU 성능을 측정하는 단이로 사용된다.

AVR Atmega128
란 = AVR Core + CPU Peripherals(I/O Port, Timer/Counter)
처음에 ZigBee 기반의 센서 네트워크 노드들이 대부분 ATmega128이였습니다. 
아날로그 TV나 지하철, 버스 등에 사용되는 교통카드 리더기 내에는 ATmega128과 Pin to Pin 호환되는 ATmega64가 사용된다.

AVR 프로세서용 바이너리 실행 코드인 HEX 파일
컴파일 된 후 메모리에 loading 된 후 Fetch => Decode => Execute 과정을 거쳐 CPU Peripheral(Controller) 내에 있는 특정 레지스터에 ALU 연산 결과 값이 적용되면 그 결과로 CPU와 연결되어 있는 주변 장치 (여기서는 LED)를 제어하도록 되는 과정입니다.

※ 임베디드 시스템(Embedded System)이란 말의 반대말은 무엇인가? => 범용 시스템(General Purpose System)입니다.

-범용 시스템은 사용하는 사람의 목적에 따라 하드웨어는 전혀 변함이 없는데, 게임용 PC로도 되었다가 쇼핑용 PC로도 되고, 개발용 PC로도 되었다가 동영상 감상용 PC로도 됩니다.

-임베디드 시스템은 어느 특정 목적(=제품 기능 목록=제품 사양)만을 위해 비용(Cost)적인 측면으로 가장 최적화(Optimization)시켜 개발시킨 시스템이 바로 임베디드 시스템이며, 그렇게 최적화가 되어 있기 때문에 더 이상의 시스템 업그레이드는 불가능합니다.

-어느 특정 목적을 위해 만들어진 시스템이며, 우리가 작성하게 될 임베디드 소프트웨어 역시 어느 특정 장치를 제어하기 위해 만들어진 소프트웨어이기 때문에, 우리가 관심가져야 할 레지스터는 사실 CPU Core 내에 있는 범용 레지스터가 아니라 CPU Peripheral 내에 있는 레지스터입니다.

1. AVR ATmega128 Specification
-메모리 : 128KB Flash, 4KB SRAM, 4KB EEPROM
-입출력(I/O) : A~F port + G port = 8 x 6 + 5 = 53 I/O pin
-디버깅 : JTAG 인터페이스 지원
-타이머/카운터 : 8 비트 타이머/카운터 2개, 16비트 타이머/카운터 2개, 총 4개
-ADC : 8채널 10비트 ADC 내장
-통신 : USART (시리얼 통신) 2채널, TWI(I2C) 1채널, SPI 1채널
-특이 사항 : Boot Loader를 통해 Self-Programming 지원 , Firmware Upgrade용으로 사용
-ATmega 128 : 5V 조건에서 최대 16MHz로 동작
-ATmega 128L : 3.3V 조건에서 최대 8MHz로 동작 ZigBee 기반의 센서 네트워크 노드와 같이 저전력 단말기에 사용
3가지의 메모리들을 내장
128KB Flash, 4KB SRAM, 4KB EEPROM
이것들은 Program Memory와 Data memory로 구분할 수 있다.

3. 앞으로 다루게 될 강의 주제들
-AVR 입출력(I/O) 포트 제어
-AVR 타이머/카운터(TImer/Counter) 제어
-AVR 외부 인터럽트(External Interrupt) 제어
-AVR 시리얼 통신 (USART) 제어
-AVR TWI (I2C) 제어
-AVR RTOS(uC/OS-Ⅱ) 포팅

## Zigbee 직비 위키
직비(영어: ZigBee)는 소형, 저전력 디지털 라디오를 이용해 개인 통신망을 구성하여 통신하기 위한 표준 기술이다. IEEE 802.15 표준을 기반으로 만들어졌다. 직비 장치는 메시 네트워크 방식을 이용, 여러 중간 노드를 거쳐 목적지까지 데이터를 전송함으로써 저전력임에도 불구하고 넓은 범위의 통신이 가능하다. 애드혹 네트워크적인 특성으로 인해 중심 노드가 따로 존재하지 않는 응용 분야에 적합하다.

직비는 낮은 수준의 전송 속도만 필요로 하면서 긴 베터리 수명과 보안성을 요구하는 분야에서 사용된다. 초당 250 kbit의 전송 속도를 가지며, 주기적 또는 간헐적인 데이터 전송이나 센서 및 입력 장치 등의 단순 신호 전달을 위한 데이터 전송에 가장 적합하다. 응용 분야에는 무선 조명 스위치, 가내 전력량계, 교통 관리 시스템, 그 밖에 근거리 저속 통신을 필요로 하는 개인 및 산업용 장치 등이 있다. 직비 표준은 블루투스나 와이파이 같은 다른 WPAN 기술에 비해 상대적으로 더 단순하고 저렴한 기술을 목표로 만들어졌다.

## 뻔뻔강사 AVR 강의 4강
avr 입출력 포트 내부 구조 분석

sw를 led로 켜고 끄려면 led와 연결된 avr 프로세서의 핀에 높은 전호 (전압) 값이 든 낮은 신호값이든 해당 신호를 흘려줘야, 다시말해 출력해줘야한다

모든 cpu는 우리가 작성한 sw를 분석하여 실행(연산) 시켜주는 cpu core
실행결과를 실제 내부 혹은 외부 디바이스에 제어를 담당하는 cpu peripheral(controller)로 구성되어 있다

led와 같은 입출력 디바이스들을 제어하는 avr 프로세서의 cpu peripheral (controller)를 입출력 포트라고 부르고 있다.

즉 우리가 sw로 led를 제어하기 위해서는 바로 이 입출력 포트 내부에 있는 sfr special function register들을 제어해야 한다는 것이다

1) 신호값 High Voltage H 경우: 출력방향 = 출력핀 = LED와 같은 출력 디바이스 제어
2) 신호값 Low Voltage L 경우 : 입력방향 = 입력핀 = Key Button 과 같은 입력 디바이스 제어

High Voltage(H) 신호나 Low Voltage(L) 신호는 모두 하드웨어(전기)적인 상태인데, 어떻게 소프트웨어적으로 이란한 하드웨어 상태를 만들어 낼 수 있을 까?
=> 레지스터(Register)를 이용합니다.

하드웨어를 소프트웨어로 제어하려면 레지스터를 소프트웨어적으로 설명해 준다고 설명한 바 있습니다.

즉, 우리가 간접적으로 CPU Core가 해줘야 할 일들을 명시하는 소스 코드가 바로 AVR용 Firmware가 되는 것입니다.

2. AVR 입출력(I/O) 포트 제어 순서 및 관련 레지스터 분석

일반적으로 Firmware가 되었든 Device Driver가 되었든, 소프트웨어로 하드웨어를 제어하려면 다음과 같은 순서로 제어하게 됩니다.

① 초기화 -> ② 설정 -> ③ 활성화

3. AVR 입출력(I/O) 포트 제어 관련 레지스터 분석

이제껏 살펴 본 입출력 포트를 제어하기 위해 필요한 레지스터들에는 어떤 것들이 있는지 살펴보도록 하겠습니다.

입출력 핀의 방향(출력 혹은 입력)을 결정하는 레지스터 이름은 DDR, 출력 핀으로 방향이 설정되었을 경우 외부 출력 디바이스로 보내 줄 신호 값을 저장하는 레지스터 이름은 PORT, 입력 핀으로 방향이 설정되었을 경우 외부 입력 디바이스로부터 입렫된 신호 값을 저장하는 레지스터 이름은 PIN 레지스터라 불리고 있을을 알 수 있습니다.

그런데, 각 레지스터 이름 옆에 (x)라는 기호가 하나 더 보이고 있습니다.

ATmega128 데이터시트의 "Pin Configuration" 부분에 있는 ATmega128 핀들의 이름을 나타내고 있는 그림입니다. 굵은 박스로 되어 있는 부분들을 보면 PE0와 같은 식으로 이름드이 지어져 있습니다.

28번 핀은 (TXD1/INT3)PD3와 같이 여러 가지 이름을 갖는 핀들이 있습니다. 이는 이름에서 알 수 있듯이 3가지의 기능들이 28번 핀 하나에 모두 연결이 되어 있다는 뜻입니다.

(TXD1/INT3)들은 Alternate Function, 괄호 바깥에 있는 PD3은 Default Function입니다. 즉, 별다른 설정이 없는 경우엔 디폴트로 PD3 (입출력)으로 사용되며, 만약 별 다른 설정이 있는 경우엔 시리얼 통신을 하는 용도(TXD1)로 사용되거나, 외부 디바이스로부터의 신호를 감지하여 인터럽트 발생 여부를 확인하는 용도(INT3)로 사용된거나 할 수 있다는 얘기입니다.

만약 PD3 핀의 입출력 방향을 결정하는 DDRD에서 PD3 핀을 출력 핀으로 설정하고, INT3 핀도 사용하겠다고 관련 레지스터를 설정했다고 가정해 봅시다. INT3 핀은 앞서 외부 디바이스로부터의 신호를 감지, 즉 입력을 받아 인터럽트 발생 여부를 알아낸다고 했으니 PD3 출력핀과 신호 방향이 서로 다르게 되어 충돌이 일어날 수도 있습니다.

따라서, AVR 프로세서에서는 Alternate Function의 우선 순위를 Default Function보다 높게 책정하고 있습니다. 즉, 아무리 DDRD에 PD3 핀을 출력핀으로 설정했다 하더라도, INT3 핀으로 사용하겠다고 관련 레지스터를 설정하게 되면 28번 핀은 PD3가 아닌 INT3으로 동작하게 됩니다.
